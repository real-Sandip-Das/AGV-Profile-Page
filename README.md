# Sandip Das

**Student Details**:

- Pursuing BS (4 year) in Mathematics and Computing
- Member of the Software Team
- A Sophomore as of Aug 2024

## Minimum Curvature trajectory planning

*Completed* \
**Reference Paper**: [Minimum curvature trajectory planning and control for an autonomous race car](https://doi.org/10.1080/00423114.2019.1631455)

- **Link to Implementation**: [AGV-2023-Planning-Teams/minimum_curvature_planner](https://github.com/AGV-2023-Planning-Teams/minimum_curvature_planner)
- Calculated the QP problem that needs to be passed to a solver
- Coded a setup to visualize output trajectories
- Created a Powerpoint presentation to describe the algorithm

## Autoware Course

*Ongoing* \
**Course Link**: [Autoware course hosted by Apex.AI](https://github.com/real-Sandip-Das/Autoware2020CourseDocumentation)

- **Documentation Link**: [GitHub link to my documentation](https://github.com/real-Sandip-Das/Autoware2020CourseDocumentation)

## Long Term Simulation Task

*Completed* \
**Task Link**: [tharun-selvam/sim_task_agv](https://github.com/tharun-selvam/sim_task_agv)

- This project consists of multiple GitHub repositories edited by myself.
- [github.com/real-Sandip-Das/sim_task_agv](https://github.com/real-Sandip-Das/sim_task_agv) (Main repository, contains explanations, instructions and links to other packages)
- [real-Sandip-Das/aruco_opencv_to_cartographer_landmark](https://github.com/real-Sandip-Das/aruco_opencv_to_cartographer_landmark) (a custom ROS Package for translating Aruco Detection messages to a format useful for Google Cartographer SLAM Nodes)
- I was required to detect Aruco markers from the camera's topic, but initially I couldn't find a package that was able to do that, so I decided to select a specific package, clone its source locally and debug it.
- [fictionlab/ros_aruco_opencv](https://github.com/fictionlab/ros_aruco_opencv) (I debugged its `noetic` branch and made a Bug Fix in this repository: [Pull Request for my Bug Fix](https://github.com/fictionlab/ros_aruco_opencv/pull/45) and then used this in my project)
- **Docker**: After completing the project, I uploaded the Docker Image for an easier experience of potential evaluators: [realsandipdas/sim_task_agv/](https://hub.docker.com/repository/docker/realsandipdas/sim_task_agv/)

## Conflict Based Search

*Edited and Improved* \
**Link to Paper**: [Conflict-based search for optimal multi-agent pathfinding](https://doi.org/10.1016/j.artint.2014.11.006)

- Task based on implementation of an algorithm described in a paper
- Although this task was assigned during the selection process, I have been polishing my solution (simply, so that I can show this to other people as a project in general)
- **GitHub Repository**: [real-Sandip-Das/Conflict-Based-Search/tree/converting_in_cpp](https://github.com/real-Sandip-Das/Conflict-Based-Search/tree/converting_in_cpp)

## Introductory ROS Task 1

*Completed* \
[Google Doc with Problem statement and relevant details](https://docs.google.com/document/d/1OhTyhqbF9AmXvqavk3pljdnWdggEaLWJNToXuGUitWs/edit)

- In short, contains a publisher and a subscriber node, both written in C++, where things like the published dummy string, topic(for publishing/subscribing to), queue size of subscriber node are customizable using ROS Parameters
- **GitHub Repository**: [real-Sandip-Das/pub_sub_comm](https://github.com/real-Sandip-Das/pub_sub_comm)
- **Documentation**: contained in the GitHub repository's `README.md` file

## Introductory ROS Task 2

*Completed* \
[Google Doc with Problem statement and relevant details](https://docs.google.com/document/d/1OhTyhqbF9AmXvqavk3pljdnWdggEaLWJNToXuGUitWs/edit)

- This task involves a light amount of mathematics, so I've used **LaTeX(MathJax)** to document the mathematical details (calculations)
- The entire C++ Source code is documented(along with the mathematical details) using **Doxygen** (proper instructions are given in the repository's `README.md`)
- **GitHub Repository**: [real-Sandip-Das/noisy_turtle_playback](https://github.com/real-Sandip-Das/noisy_turtle_playback)
- **Documentation**: contained in the GitHub repository's `README.md` file
- I know I could just use a library function to generate samples of a Bi-variate Normal Distribution, but I thought it would be fun to involve mathematics with proper documentation in this task.

## Introductory ROS Course by ETH, Zurich

*Completed* \
**Course Link**: [Programming for Robotics - ROS](https://rsl.ethz.ch/education-students/lectures/ros.html)

- **Documentation**: [real-Sandip-Das/AGV-ROS-task-doc](https://github.com/real-Sandip-Das/AGV-ROS-task-doc)
- **GitHub Repositories**: [smb_highlevel_controller](https://github.com/real-Sandip-Das/smb_highlevel_controller), [smb_highlevel_controller/tree/Exercise2(branch)](https://github.com/real-Sandip-Das/smb_highlevel_controller/tree/Exercise2)

## Introductory Git Task

*Completed* \
**Task Link**: [Cath3dr4l/AGV-git-task](https://github.com/Cath3dr4l/AGV-git-task)

- **Documentation**: [real-Sandip-Das/AGV-git-task-doc](https://github.com/real-Sandip-Das/AGV-git-task-doc)
- **GitHub Repository**: [real-Sandip-Das/AGV-git-task](https://github.com/real-Sandip-Das/AGV-git-task)
